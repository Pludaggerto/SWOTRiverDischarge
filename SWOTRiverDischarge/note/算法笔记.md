# BAM

目前https://sourcegraph.com/github.com/markwh/bamr的范例不能使用，可以尝试使用https://github.com/craigbrinkerhoff/geoBAMr

## 1 数据准备

### bam_data

> 数据准备，生成之后的bam_estimate的数据

```R
Wobs,Sobs,dAobs,logQ_hat # 观测数据
hasdat_man,hatdat_amhg # 该段观测数据是否满足两者所需
ntot_man,ntot_amhg # 满足两方法的数据组的总数
dAshift # dA在时间尺度上的均值减最小值
nx,nt # 横截面与时间'
```

### bam_setting

> 设置bam算法计算所需要的参数

```R
bam_settings <- settings::options_manager(
# options_manager 类似于python中字典的作用
```

The `minmax` function used in the “upperbound_logQ” parameter takes the minimum in space of the maximum in time for each location.

## 2 建立先验

### bam_prior

> 设置先验数据

以下将参数进行代换

```r
  myparams0 <- rlang::quos(..., .named = TRUE)
  myparams <- do.call(settings::clone_and_merge, 
                      args = c(list(options = bam_settings), myparams0))
```

总体上，代码将所有先验数据计算为一个类，其包含了大部分的数据。

## 3 进行估计

### bam_estimate

> 计算所对应的结果

判断类型

```R
  baminputs$meas_err <- ifelse(meas_error && !reparam, 1, 0)
  baminputs$inc_m <- ifelse(variant %in% c("manning", "manning_amhg"), 1, 0)
  baminputs$inc_a <- ifelse(variant %in% c("amhg", "manning_amhg"), 1, 0)
```

## 4 stan模型

### data

- Options：包括是否使用曼宁`inc_m`,`inc_a`,`meas_err`等变量
- Dimensions：包括河段数`nx`，时间节点数`nt`等变量
- Missing data：判断是否该段没有数据
- Actual data：实际的测量数据
- Hard bounds：用于限制的范围数据
- Likelihood parameters：似然参数，是已知的
- Hyperparameters：超参数，包括`logQ_hat`

### transformed data

根据data进行进一步计算生成的内容

- `dApos_array` 将所有dA变为正数

- 还有一系列将数组进行匹配计算的内容

~~~R
  // convert pseudo-ragged arrays to vectors
  Wobsvec_man = ragged_vec(Wobs, hasdat_man);
  Wobsvec_amhg = ragged_vec(Wobs, hasdat_amhg);
  Wobsvec = inc_a ? Wobsvec_amhg : Wobsvec_man;
  Sobs_vec = ragged_vec(Sobs, hasdat_man);
  dApos_obs = ragged_vec(dApos_array, hasdat_man);
  
  logWobs_man = log(Wobsvec_man);
  logSobs = log(Sobs_vec);
  
  sigmavec_man = ragged_vec(sigma_man, hasdat_man);
  sigmavec_amhg = ragged_vec(sigma_amhg, hasdat_amhg);
  
  // indices of vectorized hasdat_amhg that correspond to indices of 
  // vectorized hasdat_man
  maninds_amhg = commoninds(hasdat_amhg, hasdat_man);
~~~

### parameters

> 这里包含了我们期望计算的参数

~~~R
  vector<lower=lowerbound_logQ,upper=upperbound_logQ>[nt] logQ;
  real<lower=lowerbound_logn,upper=upperbound_logn> logn[inc_m];
  vector<lower=lowerbound_A0,upper=upperbound_A0>[nx] A0[inc_m];
  
  real<lower=lowerbound_logWc,upper=upperbound_logWc> logWc[inc_a];
  real<lower=lowerbound_logQc,upper=upperbound_logQc> logQc[inc_a];
  vector<lower=lowerbound_b,upper=upperbound_b>[nx] b[inc_a];
  
  vector<lower=0>[ntot_w] Wact[meas_err];
  vector<lower=0>[ntot_man] Sact[meas_err * inc_m];
  vector[ntot_man] dApos_act[meas_err * inc_m];
~~~

### transformed parameters

> 进一步转换参数

下面是对数据计算的初始化，可以看出这里是第一格按照公式计算

~~~c++
  
// Manning params
  if (inc_m) {
    if (meas_err) {
      Wact_man[1] = Wact[1][maninds_amhg];
      logA_man[1] = log(ragged_col(A0[1], hasdat_man) + dApos_act[1]);
      man_lhs[1] = 4. * log(Wact_man[1]) - 3. * log(Sact[1]);
    }
    else{
      logA_man[1] = log(ragged_col(A0[1], hasdat_man) + dApos_obs);
      man_lhs[1] = 4. * logWobs_man - 3. * logSobs;
    }
    
    logQ_man[1] = ragged_row(logQ, hasdat_man);
    man_rhs[1] = 10. * logA_man[1] - 6. * logn[1] - 6. * logQ_man[1];
  }
  
  // AMHG params
  if (inc_a) {
    logQ_amhg[1] = ragged_row(logQ, hasdat_amhg);
    amhg_rhs[1] = ragged_col(b[1], hasdat_amhg) .* (logQ_amhg[1] - logQc[1]) + logWc[1];
  }
~~~

### model

> 关键的模型定义环节

首先是先验部分

~~~C++
  // Priors
  logQ ~ normal(logQ_hat, logQ_sd);
  
  if (inc_m) {
    A0[1] + dA_shift[1] ~ lognormal(logA0_hat, logA0_sd);
    logn[1] ~ normal(logn_hat, logn_sd);
  }
  if (inc_a) {
    b[1] ~ normal(b_hat, b_sd);
    logWc ~ normal(logWc_hat, logWc_sd);
    logQc ~ normal(logQc_hat, logQc_sd);
  }
~~~

之后是似然部分

~~~C++
  // Manning likelihood
  if (inc_m) {
    man_lhs[1] ~ normal(man_rhs[1], 6 * sigmavec_man);
  }
~~~

# MetroMan

## params

```
Chain length
10000 
Burn in
2000 
Random Number Seed 
9 
Initial and final time (first and last days) to use in estimate 
10	40	
Prior mean on mean discharge [m3/s] 
376.998810	
Prior coefficient of variation on mean flow [fraction... set to 0.5 for typical application 
0.5	
n version to use 
4 
Geomorph priors from Craig: loga_hat	loga_sigma	b_hat	b_sigma	logA0_hat	logA0_sigma
-3.160721819	1.29348539	0.148108389	0.474298871	7.222566019	1.338002098
```

主要是

## EstData.pkl and RunData.pkl

pickle.dump的序列化数据。
